Міністерство освіти і науки України Харківський національний університет радіоелектроніки

Кафедра програмної інженерії

Звіт
З лабораторної роботи №3
З дисципліни «Аналіз та рефакторинг коду»
на тему: «РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ »

Виконала:
ст. гр. ПЗПІ-22-7	Лаврович О. С.

Перевірив:
ст. викладач кафедри ПІ	Сокорчук І. П.








Харків 2024
3  РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ


1.	Мета заняття
Розробити бізнес-логіку та функції адміністрування серверної частини  програмної системи.
2.	Завдання
1. Розробити бізнес логіку серверної частини програмної системи.
2. Розробити функції адміністрування серверної частини програмної системи.
3. Створити програмну реалізацію бізнес логіки та функцій адміністрування серверної частини.
4. Перевірити роботу серверної частини системи.
3.	Хід роботи
3.1 Бізнес логіка
1. Користувачі (Users)
Реєстрація та аутентифікація
•	Реєстрація: При реєстрації нового користувача система перевіряє, чи існує вже користувач з таким же email. Якщо ні, то створюється новий запис у таблиці Users.
•	Логін: При логіні система перевіряє, чи існує користувач з вказаним email, а потім перевіряє правильність пароля. Якщо все вірно, користувач отримує токен доступу.
Управління профілем
•	Користувачі можуть оновлювати свої дані (наприклад, телефон або тип сповіщень) через API.
•	Користувачі можуть видаляти свої акаунти, що призводить до видалення всіх пов'язаних даних.
2. Локації (Locations)
Управління локаціями
•	Адміністратори можуть створювати, оновлювати та видаляти локації.
•	Користувачі можуть переглядати всі доступні локації та отримувати деталі про конкретну локацію.
3. Загрози (Threats)
Створення та управління загрозами
•	Загрози можуть бути створені на основі даних IoT, які перевищують певні пороги (наприклад, температура, вологість, рівень газу).
•	Система автоматично генерує загрози, якщо дані IoT вказують на небезпечні умови.
•	Адміністратори можуть оновлювати або видаляти загрози.
4. IoT Дані (IoTData)
Збір та обробка даних
•	Дані IoT надходять у систему через API, де вони зберігаються в таблиці IoTData.
•	Система може автоматично генерувати загрози на основі даних IoT, якщо виявлено небезпечні умови (наприклад, виявлення диму або високий рівень газу).
5. Сповіщення (Alerts)
Генерація та управління сповіщеннями
•	Сповіщення створюються автоматично, коли виявляється загроза, або можуть бути створені вручну адміністраторами.
•	Сповіщення можуть мати різні статуси (надіслано, доставлено, прочитано), і система відстежує ці статуси.
6. Сповіщення для користувачів (User Alerts)
Управління сповіщеннями для користувачів
•	Коли сповіщення створюється, система перевіряє, які користувачі підписані на сповіщення для конкретної загрози, і створює записи в таблиці User Alerts.
•	Користувачі можуть переглядати свої сповіщення та оновлювати статуси (наприклад, прочитано).
7. Поточні загрози та дані
Моніторинг загроз
•	Система надає API для отримання поточних загроз, які потребують уваги (наприклад, загрози з високим рівнем небезпеки).
•	Користувачі можуть отримувати загрози для конкретних локацій, що дозволяє їм бути в курсі ситуації.
Додаткові функції
•	Безпека: Всі API повинні бути захищені, щоб уникнути несанкціонованого доступу. Використання токенів доступу для аутентифікації користувачів.
•	Сповіщення в реальному часі: Використання WebSocket або інших технологій для надсилання сповіщень користувачам у реальному часі, коли виникають нові загрози або сповіщення.
•	Кастомізація сповіщень: Користувачі можуть налаштовувати, які типи сповіщень вони хочуть отримувати, а також обирати способи отримання (SMS, Email, обидва).
•	Звіти та аналітика: Адміністратори можуть генерувати звіти про загрози, сповіщення та активність користувачів для покращення управління системою.
Логіка визначення типу загрози
1. Класифікація загроз
Дані, що надходять із сенсорів (temperature, humidity, gas_level, smoke_detected), обробляються за допомогою формул, щоб визначити, чи вони перевищують встановлені порогові значення.
Наприклад:
Формула оцінки загрози на основі газового рівня:
 
•  Пожежа
•	Умови:
o	temperature > 70
o	smoke_detected = TRUE
•	Дії: Викликати екстрені служби та евакуювати персонал.
•  Витік газу
•	Умови:
o	gas_level > 300
•	Дії: Закрити газопостачання, провітрити приміщення, викликати газову службу.
•  Задимлення
•	Умови:
o	smoke_detected = TRUE
o	temperature <= 70
•	Дії: Провітрити приміщення, перевірити джерело диму.
•  Небезпечна вологість
•	Умови:
o	humidity > 90
•	Дії: Перевірити ізоляцію електрообладнання та вентиляцію.
•  Перегрівання
•	Умови:
o	temperature > 50 AND temperature <= 70
•	Дії: Перевірити системи охолодження.
•  Критична комбінація факторів (потенційна вибухонебезпека)
•	Умови:
o	temperature > 70
o	gas_level > 300
•	Дії: Негайно евакуювати персонал, закрити доступ до приміщення, викликати спеціальні служби.

2. Правила для створення загроз
•	Якщо IoT-дані перевищують порогові значення, система автоматично створює загрозу.
•	Алгоритм:
1.	Дані сенсорів обробляються в реальному часі.
2.	Визначаються ключові показники (температура, газ, дим).
3.	Якщо умова перевищення порогів виконується:
	Визначається тип загрози.
	Обчислюється рівень небезпеки.
	Генерується запис у таблиці Threats.
Можливі загрози на основі доступних полів IoT-даних
На основі полів таблиці IoTData можна ідентифікувати такі загрози:
1.	Пожежа
o	Умови: 
	temperature > 70
	smoke_detected = TRUE
o	Дії: Викликати екстрені служби та евакуювати персонал.
2.	Витік газу
o	Умови: 
	gas_level > 300
o	Дії: Закрити газопостачання, провітрити приміщення, викликати газову службу.
3.	Задимлення
o	Умови: 
	smoke_detected = TRUE
	temperature <= 70
o	Дії: Провітрити приміщення, перевірити джерело диму.
4.	Небезпечна вологість
o	Умови: 
	humidity > 90
o	Дії: Перевірити ізоляцію електрообладнання та вентиляцію.
5.	Перегрівання
o	Умови: 
	temperature > 50 AND temperature <= 70
o	Дії: Перевірити системи охолодження.
6.	Критична комбінація факторів (потенційна вибухонебезпека)
o	Умови: 
	temperature > 70
	gas_level > 300
o	Дії: Негайно евакуювати персонал, закрити доступ до приміщення, викликати спеціальні служби.

3. 	Логіка розрахунку рівня небезпеки (Severity Level)
Рівень небезпеки визначається як числове значення від 0 до 10 на основі аналізу значень IoT-даних. Усі дані нормалізуються, щоб впливати на загальний рівень уніфіковано.
Формула обчислення
 
•	Нормалізовані значення:
o	NormTemp:
 
(Наприклад, minTemp=0C, maxTemp=100C).
o	NormGas:
 
(Наприклад, maxGasLevel=1000 ppm).
o	NormHumidity:
 
o	SmokeFactor:
	1, якщо smoke_detected = TRUE.
	0, якщо smoke_detected = FALSE.
•	Ваги:
o	Weighttemp=0.4
o	Weightgas=0.3
o	Weightsmoke=0.2
o	Weighthumidity=0.1
Приклад розрахунку
Якщо:
•	temperature = 85
•	gas_level = 400
•	smoke_detected = TRUE
•	humidity = 95
Тоді:
 
Розрахунок рівня:
 Таким чином, рівень небезпеки становить 8.
Пріоритет загроз
•	9-10: Негайне втручання, висока небезпека (наприклад, пожежа, вибухонебезпека).
•	7-8: Високий рівень уваги, значна небезпека (наприклад, витік газу).
•	4-6: Середній рівень загрози (наприклад, задимлення або перегрівання).
•	1-3: Низький рівень загрози (наприклад, підвищена вологість).
•	0: Загроза відсутня.

3.2 Розробити функції адміністрування серверної частини програмної системи.
Функції адміністрування
1. Управління користувачами
1.1. Перегляд користувачів
•	Опис: Отримання списку всіх користувачів з деталями, включаючи їх статус активності.
•	Ендпоінт: GET /api/admin/users
•	Логіка:
o	Перевірити роль запитувача (доступ лише для адміністраторів).
o	Повернути дані всіх користувачів, зокрема:
	ID, ім'я, email, телефон, тип користувача, дата створення, статус.
1.2. Активізація/деактивація користувачів
•	Опис: Адміністратор може активувати або деактивувати обліковий запис користувача.
•	Ендпоінт: PUT /api/admin/users/:id/status
•	Логіка:
o	Перевірити роль адміністратора.
o	Змінити статус користувача (active/inactive).
o	Відправити повідомлення користувачеві про зміну статусу.
2. Управління загрозами
2.1. Видалення загроз
•	Опис: Видалення старих або неактуальних загроз.
•	Ендпоінт: DELETE /api/threats/delete
•	Логіка:
o	Приймається список ID загроз для видалення.
o	Видаляються тільки загрози зі статусом "неактивна".
o	Логування видалення з датою та часом.

3. Управління IoT-даними
3.1. Очищення старих даних
•	Опис: Видалення IoT-даних, які більше не використовуються для аналітики.
•	Ендпоінт: DELETE /api/admin/iot-data/cleanup
•	Логіка:
o	Приймається дата (before_date).
o	Видаляються всі дані, створені до вказаної дати.
o	Створюється запис про очищення у логах системи.


3.3 Створити програмну реалізацію бізнес логіки та функцій адміністрування серверної частини
Почнемо з бізнес-логіки. Реєстрація, логін, та дії з користувачами були зроблені та протестовані в минулій лабораторній роботі. Потрібно лише додати роботу з токеном, та перевірку на роль користувача. 

Далі, створили всі потрібні CRUD дії для всіх моделей. 
 
Розробимо логіку для розрахунку рівня небезпеки, класифікації загроз і обробки даних IoT.(Код наведено в додатку А)
Вона включає:
1.	Розрахунок рівня небезпеки на основі ваг та нормалізації вхідних даних.
2.	Класифікацію загроз відповідно до умов (температура, газ, дим, вологість).
3.	Автоматичне створення записів загроз у базі даних, якщо умови загроз виконуються.
Сповіщення. Реалізація методу getSubscribedUsers: Цей метод буде отримувати користувачів, підписаних на сповіщення для конкретної загрози (на основі threat_id). Метод notifyUsers: Цей метод відповідає за створення записів для кожного користувача, підписаного на сповіщення для певної загрози, коли створюється нове сповіщення.
  1 class NotificationService {
  2     // Метод для надсилання сповіщень користувачам
  3     static async notifyUsers(alert) {
  4       try {
  5         // Отримання списку користувачів, які підписані на сповіщення для конкретної загрози
  6         const subscribedUsers = await this.getSubscribedUsers(alert.threat_id);
  7
  8         // Створення записів у таблиці UserAlert для кожного підписаного користувача
  9         for (const user of subscribedUsers) {
 10           await UserAlert.create({
 11             user_id: user.id,
 12             alert_id: alert.id,
 13             notification_sent: false, // Сповіщення ще не надіслано
 14           });
 15         }
 16       } catch (error) {
 17         throw new Error('Error notifying users: ' + error.message);
 18       }
 19     }
 20
 21     // Метод для отримання користувачів, підписаних на сповіщення для конкретної загрози
 22     static async getSubscribedUsers(threatId) {
 23       try {
 24         const users = await User.findAll({
 25           include: [{
 26             model: ThreatSubscription, // Модель, яка зберігає підписки на загрози
 27             where: { threat_id: threatId }
 28           }]
 29         });
 30         return users;
 31       } catch (error) {
 32         throw new Error('Error fetching subscribed users: ' + error.message);
 33       }
 34     }
 35   }

Моніторинг загроз. Для цього створили дві функції. 
  1 // Отримати поточні загрози, що потребують уваги
  2 const getCurrentThreats = async () => {
  3     try {
  4       const threats = await Threat.findAll({
  5         where: {
  6           severity_level: {
  7             [Op.gte]: 7, // severity_level >= 7
  8           },
  9         },
 10       });
 11       return threats;
 12     } catch (error) {
 13       throw new Error('Error retrieving current threats');
 14     }
 15   };
 16   router.get('/api/current-threats', async (req, res) => {
 17     try {
 18       const threats = await ThreatService.getCurrentThreats();
 19       return res.status(200).json(threats);
 20     } catch (error) {
 21       res.status(500).json({ error: error.message });
 22     }
 23   });
 24
 25   // Отримати загрози для конкретної локації
 26   const getThreatsByLocation = async (locationId) => {
 27     try {
 28       const threats = await Threat.findAll({
 29         where: {
 30           data_id: locationId, // data_id як зовнішній ключ для локацій
 31         },
 32       });
 33       return threats;
 34     } catch (error) {
 35       throw new Error('Error retrieving threats for location');
 36     }
 37   };
 38
 39   router.get('/api/locations/:id/threats', async (req, res) => {
 40     const { id } = req.params;
 41     try {
 42       const threats = await ThreatService.getThreatsByLocation(Number(id));
 43       return res.status(200).json(threats);
 44     } catch (error) {
 45       res.status(500).json({ error: error.message });
 46     }
 47   });

Переходимо до функцій адміністрування. 	Спершу, змінимо маршрут для отримання всіх користувачів, щоб була перевірка на роль користувача, і лише адміністратор мав доступ. 
  1 // Middleware для перевірки ролі адміністратора
  2 const isAdmin = (req, res, next) => {
  3     if (req.user && req.user.role === 'admin') {
  4       return next();
  5     }
  6     return res.status(403).json({ message: 'Доступ заборонено' });
  7   };
  8
  9   // Ендпоінт для отримання всіх користувачів
 10   router.get('/api/admin/users', isAdmin, async (req, res) => {
 11     try {
 12       const users = await getAllUsers();
 13
 14       return res.status(200).json(users);
 15     } catch (error) {
 16       console.error(error);
 17       return res.status(500).json({ message: 'Внутрішня помилка сервера' });
 18     }
 19   });
 20

Далі, додамо можливість деактивації користувачів адміністратором.
  1 const toggleUserStatus = async (userId) => {
  2     try {
  3       // Знаходимо користувача за ID
  4       const user = await User.findByPk(userId);
  5
  6       if (!user) {
  7         throw new Error('Користувача не знайдено.');
  8       }
  9
 10       // Змінюємо статус на протилежний
 11       user.status = user.status === 'active' ? 'inactive' : 'active';
 12       await user.save();
 13
 14       // Повертаємо оновленого користувача
 15       return user;
 16     } catch (error) {
 17       console.error(error);
 18       throw new Error('Не вдалося змінити статус користувача.');
 19     }
 20   };
 21 // Ендпоінт для активації/деактивації користувача
 22 router.put('/api/admin/users/:id/status', isAdmin, async (req, res) => {
 23     const userId = req.params.id;
 24
 25     try {
 26       const updatedUser  = await toggleUserStatus(userId);
 27       return res.status(200).json({ message: `Статус користувача ${updatedUser.email} змінено на ${updatedUser.status}.` });  
 28     } catch (error) {
 29       return res.status(500).json({ message: error.message });
 30     }
 31   });
 32
 33

Створимо функцію, яка видалятиме дані, створені до вказаної дати, і записуватиме інформацію про очищення в логах системи. 
  1 const cleanupOldIoTData = async (beforeDate) => {
  2     try {
  3       // Видаляємо дані, створені до вказаної дати
  4       const result = await IoTData.destroy({
  5         where: {
  6           timestamp: {
  7             [Op.lt]: beforeDate, // Використовуємо оператор менше
  8           },
  9         },
 10       });
 11
 12       // Записуємо інформацію про очищення в логах
 13       await Log.create({
 14         action: 'cleanup',
 15         details: `Видалено IoT-дані до дати: ${beforeDate}`,
 16         deletedCount: result,
 17       });
 18
 19       return result; // Повертаємо кількість видалених записів
 20     } catch (error) {
 21       console.error(error);
 22       throw new Error('Не вдалося очистити старі IoT-дані.');
 23     }
 24   };
 25  // Ендпоінт для очищення старих IoT-даних
 26   router.delete('/api/admin/iot-data/cleanup', isAdmin, async (req, res) => {
 27     const { before_date } = req.body; // Отримуємо дату з тіла запиту
 28
 29     if (!before_date) {
 30       return res.status(400).json({ message: 'Необхідно вказати before_date.' });
 31     }
 32
 33     try {
 34       const deletedCount = await cleanupOldIoTData(new Date(before_date));
 35       return res.status(200).json({ message: `Успішно видалено ${deletedCount} записів.` });
 36     } catch (error) {
 37       return res.status(500).json({ message: error.message });
 38     }
 39   });
Загальний висновок
У результаті виконання роботи було розроблено серверну частину програмної системи, що забезпечує ефективне адміністрування користувачів, управління загрозами та обробку IoT-даних. Реалізовані функції відповідають сучасним вимогам до серверних систем із використанням платформи Node.js та інтеграції з MySQL, що забезпечує масштабованість, надійність та безпеку програмного забезпечення. 

4.	Висновки
Під час виконання лабораторної роботи було реалізовано кілька функцій, що охоплюють основні аспекти адміністрування, управління користувачами та обробки даних про небезпечні ситуації. Зокрема, були розроблені рішення для ефективного управління користувачами, класифікації загроз та обробки IoT-даних, що значно підвищують функціональність і зручність використання системи.
Управління користувачами реалізовано через можливість отримання списку всіх користувачів із бази даних із перевіркою ролі, що обмежує доступ до цієї інформації лише адміністраторам. Також впроваджено функцію видалення користувачів за унікальним ідентифікатором (ID) та можливість їхньої деактивації, що дозволяє адміністраторам системи ефективно контролювати доступ і підтримувати безпеку. Обробка загроз включає реалізацію логіки розрахунку рівня небезпеки, класифікації загроз та інтеграції даних із IoT-пристроїв. Це дозволяє забезпечити оперативне виявлення потенційних небезпек і їх класифікацію для своєчасного реагування.
Окрім цього, розроблено функцію автоматичного видалення даних, створених до визначеної дати, із записом відповідної інформації в логи системи, що забезпечує підтримання актуальності та зручності роботи з базою даних.
Результати роботи підтверджують доцільність застосування сучасних підходів до розробки серверних систем із використанням Node.js та MySQL, що забезпечують масштабованість, надійність та безпеку програмного забезпечення.

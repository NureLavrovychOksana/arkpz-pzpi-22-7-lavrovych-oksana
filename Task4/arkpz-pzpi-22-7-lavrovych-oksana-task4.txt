Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії






Лабораторна робота №4
з дисципліни: «Аналіз та рефакторинг коду»
на тему «РОЗРОБКА IoT КЛІЄНТА»





Перевірив:
викладач каф. ПІ
Сокорчук І.П	Виконала:
ст. гр. ПЗПІ-22-7
Лаврович Оксана Степанівна






Харків 2024
1.	Мета заняття
Розробити клієнт IoT, який здійснює збір, аналіз і передачу даних на сервер відповідно до принципів Інтернету речей. Реалізувати бізнес-логіку, функціонал налаштування пристрою та забезпечити інтеграцію з іншими компонентами системи.

2.	Завдання
1. Розробити будову програмного забезпечення ІоТ клієнта.
2. Створити UML діаграму прецедентів для ІоТ клієнта.
3. Розробити бізнес логіку (математину обробку повʼязаних із предметною областю даних) та функції налаштування ІоТ клієнта.
4. Створити діаграму діяльності для ІоТ клієнта.
5. Створити програмну реалізацію бізнес логіки та функцій налаштування ІоТ клієнта.
6. Перевірити роботу ІоТ клієнта.

3.	Хід роботи

3.1	 Опис бізнес логіки IoT клієнта
 
Рисунок 1 – UML Діаграма прецедентів IoT клієнта

3.2	 Процеси та взаємодії в системі IoT клієнта
Діаграма діяльності (див. рис. 2) демонструє роботу IoT-клієнта, починаючи з ініціалізації системи та спроби підключення до Wi-Fi мережі. У разі успішного підключення клієнт переходить до ініціалізації сенсорів, які які збирають дані про концентрацію газу, наявність диму, температуру та рівень вологост. Після цього система обробляє та форматує отримані дані, виводить їх у консоль для перевірки та відправляє через MQTT-брокер. Успішна передача даних завершується відповідним повідомленням, а у випадку помилки система інформує про збій, дозволяючи своєчасно реагувати на проблеми.
 
Рисунок 2 – UML -діаграма діяльності IoT клієнта

3.3	 Розробка функцій управління та інтерфейсу користувача IoT
У ході виконання лабораторної роботи було реалізовано IoT-систему для моніторингу небезпечних ситуацій, таких як пожежі, витоки газу, задимленість і несправності електромережі. Система побудована на базі мікроконтролера ESP32, що забезпечує збір, обробку та передачу даних для подальшого аналізу. Було застосовано низку інженерних рішень, які забезпечують ефективність, надійність і безпеку функціонування пристрою.
Розроблено програмний код, що дозволяє інтегрувати сенсори для моніторингу критичних параметрів, таких як наявність диму, витоки газу та зміни температури. Для цього було використано сенсори MQ-2 для газу, DHT22 для температури та вологості, а також сенсор диму. Зібрані дані обробляються безпосередньо на пристрої для зменшення шуму та виключення помилкових спрацьовувань.
ESP32 було обрано завдяки його вбудованому Wi-Fi модулю, який використовується для передачі даних на MQTT брокер. MQTT було обрано як основний протокол комунікації через його ефективність у мережах із низькою пропускною здатністю. Дані передаються у форматі JSON, що забезпечує їх зручну інтеграцію з центральною системою для моніторингу та аналізу.
Також реалізовано механізм двосторонньої комунікації: пристрій може не тільки передавати дані, але й отримувати команди від центрального сервера. Це дозволяє, наприклад, активувати сигналізацію на пристрої або виконувати оновлення конфігурації в реальному часі. Для забезпечення безпеки використовується шифрування даних за допомогою протоколу TLS, а автентифікація здійснюється на основі токенів доступу.
Програмне забезпечення IoT-клієнта створено з можливістю оновлення прошивки за допомогою OTA (Over-The-Air). Це дозволяє віддалено вдосконалювати функціональність пристрою або виправляти виявлені вразливості без потреби фізичного доступу до нього. Також передбачено механізми логування роботи пристрою для діагностики й тестування.
Тестування системи проводилося з використанням серійного монітора, де перевірялися коректність підключення до Wi-Fi, передача даних на MQTT брокер і обробка відповідей від сервера. Завдяки цьому вдалося перевірити працездатність усіх компонентів системи в умовах реальної експлуатації.
Таким чином, створена IoT-система забезпечує ефективний моніторинг небезпечних ситуацій і передає дані для подальшого аналізу й прийняття рішень. Її гнучкість і надійність дозволяють легко інтегрувати пристрій у більші екосистеми IoT, розширюючи його функціональність і масштабованість.
3.4	 Текстовий опис інженерних рішень
Програмний код IoT-пристрою реалізовано в Arduino IDE з використанням бібліотек WiFi.h для підключення до Wi-Fi мережі, PubSubClient.h для взаємодії з MQTT брокером, DHT.h для роботи з датчиком температури й вологості DHT22, MQUnifiedsensor.h для зчитування даних із газового сенсора MQ-2, а також ArduinoJson.h для формування даних у форматі JSON перед їх відправленням на сервер.
Система спочатку підключається до Wi-Fi, після чого зчитує дані з сенсорів, обробляючи їх для усунення шумів. Зібрані дані структуруються у форматі JSON і передаються на MQTT брокер для моніторингу в реальному часі. Діагностична інформація виводиться через серійний монітор для перевірки коректності роботи пристрою.
Система забезпечує безперервний моніторинг стану навколишнього середовища, передаючи дані для віддаленого аналізу та оповіщення користувачів у разі небезпечних ситуацій. 

3.5	 Фрагменти програмного коду
Фрагмент коду для зчитування даних з сенсорів та публікації в MQTT: Код наведено у додатку А.

3.5.1 Фрагмент коду підключення до Wi-Fi
1  void setup() {
2    Serial.begin(115200);
3    WiFi.begin(ssid, password);
4    
5    while (WiFi.status() != WL_CONNECTED) {
6      Serial.println("Connecting to WiFi...");
7    }
8    Serial.println("Connected to WiFi");
9    client.setServer(mqtt_server, mqtt_port);
10    sensors.begin();
11  }

3.5.2 Бізнес-логіка IoT-клієнта
Фрагмент коду для зчитування даних із сенсорів:
1 const mqtt = require('mqtt');
2 const IoTData = require('./models/iotdata'); // Підключаємо модель IoTData
3 
4 // Підключення до MQTT брокера
5 const client = mqtt.connect('mqtt://broker.hivemq.com');
6
7 client.on('connect', () => {
8   console.log('Connected to MQTT broker');
9
10   // Підписуємось на тему
11   client.subscribe('iot/data', (err) => {
12     if (!err) {
13       console.log('Subscribed to topic: iot/data');
14     } else {
15       console.error('Failed to subscribe:', err);
16     }
17   });
18 });

3.5.3 Виведення логів роботи

 20 client.on('message', async (topic, message) => {
 21   console.log(`Received message from ${topic}: ${message}`);
 22
 23   try {
 24     const data = JSON.parse(message.toString());
 25
 26     // Обчислюємо рівень небезпеки (alert_level)
 27     const alertLevel = calculateAlertLevel(data);
 28
 29     await IoTData.create({
 30       temperature: data.temperature,
 31       humidity: data.humidity,
 32       gas_level: data.gas_ppm,
 33       smoke_detected: data.smoke_ppm > 30,
 34       alert_level: alertLevel,
 35       location_id: 1,
 36     });
 37 
 38     console.log('Data saved to database:', data);
 39   } catch (error) {
 40     console.error('Error processing message:', error);
 41   }
 42 });

Приклад JSON-виходу:
  1 {
  2   "deviceId": "ESP32_Client",
  3   "timestamp": "2025-01-19T12:45:00.123Z",
  4   "data": {
  5     "temperature": "23.45",
  6     "humidity": "42.78",
  7     "gasLevel": "215.67"
  8   }
  9 }

3 ВИСНОВКИ

У процесі виконання лабораторної роботи був успішно розроблений IoT-клієнт для сповіщення про небезпечні ситуації, який здійснює збір, аналіз та передачу даних з різних сенсорів, таких як температура, вологість, концентрація газу та диму. Завдяки інтеграції з MQTT, система забезпечує надійну передачу даних на сервер для моніторингу та своєчасного реагування на потенційно небезпечні ситуації. Налаштований функціонал для сповіщень про аномальні показники дозволяє оперативно інформувати користувачів або автоматичні системи. Це підкреслює практичну цінність розробленого IoT-клієнта для застосувань у системах безпеки, що можуть бути інтегровані в більш широкі IoT-системи для ефективного управління ризиками в реальному часі.
Посилання на YouTube відео:
Посилання на файл з кодом в GitHub репозиторії: https://github.com/NureLavrovychOksana/arkpz-pzpi-22-7-lavrovych-oksana/tree/main/Task4/arkpz-pzpi-22-7-lavrovych-oksana-task4
 
Додаток А
Фрагмент коду для зчитування даних з сенсорів та публікації в MQTT

   1 #include <WiFi.h>
  2 #include <PubSubClient.h>
  3 #include <DHT.h>
  4 #include <MQUnifiedsensor.h>
  5 #include <ArduinoJson.h>
  6 
  7 // Wi-Fi конфігурація
  8 const char* ssid = "Wokwi-GUEST";
  9 const char* password = "";
 10 
 11 // MQTT конфігурація
 12 const char* mqtt_server = "broker.hivemq.com";
 13 const int mqtt_port = 1883;
 14 const char* mqtt_topic = "iot/data";
 15
 16 // Налаштування сенсорів
 17 #define DHTPIN 23        // Пін для DHT22
 18 #define DHTTYPE DHT22    // Тип сенсора DHT
 19 DHT dht(DHTPIN, DHTTYPE);
 20
 21 #define MQ2PIN A0        // Пін для MQ-2
 22 #define MQ135PIN A1      // Пін для MQ-135
 23 #define Board "ESP32"
 24 #define Voltage_Resolution 3.3
 25 #define ADC_Bit_Resolution 12
 26
 27 MQUnifiedsensor mq2(Board, Voltage_Resolution, ADC_Bit_Resolution, MQ2PIN, "MQ-2");
 28 MQUnifiedsensor mq135(Board, Voltage_Resolution, ADC_Bit_Resolution, MQ135PIN, "MQ-135");
 29
 30 WiFiClient espClient;
 31 PubSubClient client(espClient);
 32
 33 void setup() {
 34   Serial.begin(115200);
 35
 36   // Ініціалізація Wi-Fi
 37   WiFi.begin(ssid, password);
 38   while (WiFi.status() != WL_CONNECTED) {
 39     Serial.println("Connecting to WiFi...");
 40     delay(1000);
 41   }
 42   Serial.println("Connected to WiFi");
 43
 44   // Ініціалізація MQTT
 45   client.setServer(mqtt_server, mqtt_port);
 46
 47   // Ініціалізація сенсорів
 48   dht.begin();
 49   mq2.setRegressionMethod(1);    // Лінійна регресія для CO
 50   mq2.init();
 51   mq135.setRegressionMethod(1); // Лінійна регресія для диму
 52   mq135.init();
 53
 54   Serial.println("System initialized");
 55 }
 56
 57 void loop() {
 58
 59   if (!client.connected()) {
 60     reconnect();
 61   }
 62   client.loop();
 63
 64   float temperature = dht.readTemperature();
 65   float humidity = dht.readHumidity();
 66
 67   mq2.update();
 68   float gasValue = mq2.readSensor();
 69
 70   mq135.update();
 71   float smokeValue = mq135.readSensor();
 72
 73   // Обробка даних
 74   if (isnan(temperature) || isnan(humidity) || isnan(gasValue) || isnan(smokeValue)) {
 75     Serial.println("Failed to read data from sensors");
 76     return;
 77   }
 78
 79   // Формування JSON
 80   StaticJsonDocument<256> jsonDoc;
 81   jsonDoc["temperature"] = temperature;
 82   jsonDoc["humidity"] = humidity;
 83   jsonDoc["gas_ppm"] = gasValue;
 84   jsonDoc["smoke_ppm"] = smokeValue;
 85
 86   char jsonBuffer[256];
 87   serializeJson(jsonDoc, jsonBuffer);
 88
 89   // Відправлення даних до MQTT
 90   if (client.publish(mqtt_topic, jsonBuffer)) {
 91     Serial.println("Data published:");
 92     Serial.println(jsonBuffer);
 93   } else {
 94     Serial.println("Failed to publish data");
 95   }
 96
 97   delay(5000);
 98 }
 99
100 void reconnect() {
101   // Спроба підключення до MQTT
102   while (!client.connected()) {
103     Serial.print("Attempting MQTT connection...");
104     if (client.connect("ESP32Client")) {
105       Serial.println("Connected to MQTT broker");
106     } else {
107       Serial.print("Failed, rc=");
108       Serial.println(client.state());
109       delay(5000);
110     }
111   }
112 }

